# Inquiry

Write your answers below and include the questions. Do copy relevant code to your answers so that both questions and answers are in context 

# Answers

## 1. Where can you find the manual to g++?
The manual to g++ can be found at https://gcc.gnu.org/onlinedocs/

## 2. What is the purpose of -Wall and -g, when passed as arguments to g++?
The purpose of -Wall is to say that the compiler should show warnings to do with constructions. Some of these are easy to avoid and should be avoided while others are much harder to avoid (Source: https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc.pdf).

The purpose of -g is to say that the compiler should write the debugging information in the operating system's native format (Source: https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc.pdf).

## 3. What is the difference between an object file, and an executable?
An object file is a file generated by the compiler from a source file. One or more object files, after they have been linked together, are used to generate an executable file. The executable file is the file that eventually runs the code (Source: C++ Primer, Fifth edition).

## 4. What in the example above is a forward declaration?
```
struct B;
class A {
  B * b;
  int method(int x) { return x; }
};

struct B {
  A a;
  int memberfunction(int x) { return x; }
};

int main() {
  A a;
  B b;
  int x = b.memberfunction( 3 );
}
```
The line at the top of this code block is a forward declaration. It is an incomplete declaration that states that there is a struct called B defined further down in the file.

## 5. Why is it not possible to have class A containing a B object and B containing an A object?
This situation creates a circular dependency where class A is dependent on class B and class B is dependent on class A. This creates an infinite loop where to build A we need a complete definition of B but to get that we need a complete definition of A.

## 6. What is the purpose of std::cout, std::cerr, and std::clog, respectively?
The purpose of std::cout is mainly to print output of a program much like printf() in C or System.out.println() in Java. std::cerr is meant to output errors and std::clog is meant for general logging of a program. 

## 7. How does #include work?
#include tells the preprocessor to include the file specified following the #include command in the compilation. This means that I can now use functions from that file in my file and the compiler knows where to look for them.

## 8. Why is it important to test the boundary conditions of an implementation, especially in the case of count_if_followed_by?
It is usually for the boundary conditions of an implementation where something can go wrong. It's often easy to make something
work for the general case but making it work for the boundary conditions is harder. In count_if_followed_by it is easy to
see that it works in the middle of a list but harder to realise that it may fail at the boundaries. Therefore it's important
to test those.

## 9. Describe how your testcase tests if a pointer is accessing an element outside the range specified
The testcase testLast_element() runs the following: 
```count_if_followed_by({'a', 'b', 'a', 'b'}, 4, 'a', 'b');```

If this function returns 2 then the function must have accessed the last element which is outside of the range specified.






